{"version":3,"sources":["App/TreeEditor/VirtualScrollTree/Tree/definitions.ts","App/TreeEditor/VirtualScrollTree/Tree/TreeList/Item.tsx","App/TreeEditor/VirtualScrollTree/Tree/TreeList/DropAcceptor/DropAcceptorSlot.tsx","App/TreeEditor/mobx/EntityLabelStore/definitions.ts","App/TreeEditor/VirtualScrollTree/Tree/TreeList/DropAcceptor/index.tsx","App/TreeEditor/VirtualScrollTree/Tree/TreeList/DragStart/index.tsx","App/TreeEditor/VirtualScrollTree/Tree/TreeList/index.tsx","App/TreeEditor/VirtualScrollTree/Tree/index.tsx","lib/VirtualScroll/mobx/VirtualScrollStore.ts","lib/VirtualScroll/VirtualScrollArea.tsx","lib/VirtualScroll/index.tsx","App/TreeEditor/VirtualScrollTree/DropContainer.tsx","App/TreeEditor/VirtualScrollTree/ScrollContainer.tsx","App/TreeEditor/VirtualScrollTree/index.tsx","App/TreeEditor/Info/SelectedInfo.tsx","App/TreeEditor/Info/index.tsx","App/TreeEditor/Controls/index.tsx","App/TreeEditor/index.tsx","App/index.tsx","App/TreeEditor/mobx/EntityLabel/emptyEntityLabelNode.ts","App/TreeEditor/mobx/EntityLabel/index.ts","App/TreeEditor/mobx/EntityLabelStore/index.ts","App/TreeEditor/mobx/DragAndDropStore/index.ts","stores.ts","index.tsx"],"names":["nodeItemType","defaultStyle","height","ExternalItem","inject","observer","props","node","entityLabelStore","map","get","id","useDrag","type","item","end","dragAndDropStore","endDragging","collect","monitor","isDragging","drag","useEffect","startDragging","index","style","useMemo","marginLeft","level","handleClick","useCallback","setSelected","className","key","onClick","ref","classnames","Node","Node_selected","selected","label","DropAcceptorSlot","nestingLevel","onDragOver","base","useState","active","setActive","useRef","handleDragOver","handleDragLeave","renderContent","undefined","DropAcceptor__slot","DropAcceptor__slot_active","onDragLeave","ROOT_ID","DropAcceptorExternal","dropAccessorIndex","isAbleDrop","pathId","setDropIntention","parentId","_sequence","DropAcceptor","DropAcceptor_invalid","pathIds","availableDropItemIndex","childAndSiblingIds","slice","nestingStartLevel","Math","max","length","renderSlots","path","StartDrag","DROP_ACCESSOR_SIGN","START_DRAGGING_SIGN","mixinItemToSequence","sequence","resultSequence","splice","getInsertionIndex","range","outOfRange","from","to","renderList","options","startDraggingIndex","dropAccessorInsertionIndex","startDraggingInsertionIndex","newSequence","mixinSpecialItems","TreeListExternal","ExternalTree","virtualScrollStore","_map","VirtualScrollStore","this","scrollAreaHeight","itemHeight","scrollPosition","itemsTotal","floor","ceil","min","paddingBottom","contentHeight","paddingTop","observable","action","computed","VisualScrollAreaExternal","scrollStore","scrollAreaRef","handleScroll","event","scrollTop","target","setScrollPosition","current","addEventListener","setScrollAreaHeight","offsetHeight","removeEventListener","ScrollArea","Container","pads","children","VirtualScroll","createStores","stores","setItemsTotal","DropContainerExternal","useDrop","accept","drop","currentTarget","dropAreaRect","getBoundingClientRect","mouseY","clientY","top","mouseIndex","setMouseIndex","ScrollContainer","forwardRef","ScrollContainerBox","React","defaultScrollOptions","VirtualScrollTreeExternal","scrollOptions","ExternalSelectedInfo","parent","Info","ControlsExternal","handleRefresh","fetch","handleRemove","removeSelected","handleApply","apply","disabled","pending","TreeEditor","App","emptyEntityLabelNode","setParent","addChild","getBranchMembers","removeChild","getData","isLastChild","EntityLabel","_id","_label","_parent","_children","parentPath","child","indexOf","allSubBranchMembers","reduce","result","push","last","EntityLabelStore","sequenceStash","_rootNode","createMap","_selected","_pending","Map","sourceIndex","childrenEndIndex","targetPosition","removementLength","branch","targetIndex","insertIndex","sourceId","sourceNode","targetParent","childItem","currentItem","i","sourceParentPath","sourceParentPathSet","Set","has","updateNestingPointers","moveSequence","entityLabelPage","entityLongIds","forEach","labels","entryLabel","set","parentEntityLongIds","initMap","setPending","method","response","invariant","ok","json","data","setData","entityLabelPages","console","log","branchMemberIds","removeIds","filter","delete","parentIndex","updatePath","pathItem","applyNode","emptyDropIntention","DragAndDropStore","dropIntention","_startDraggingIndex","dragging","_mouseIndex","draggingItemId","upperItemId","upperItem","onlyOneDraggingChild","currentId","reverse","isLastItemCurrent","onlyChildDropAllowed","dropIndexByUpperItemLastChild","startId","endId","endItem","removeSequenceItemAndStash","unstash","moveNode","ReactDOM","render","StrictMode","DndProvider","backend","HTML5Backend","document","getElementById","f1","Promise","resolve","f2","queueMicrotask","runTimeouts","setTimeout","f3"],"mappings":"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","file":"static/js/main.941d79c6.chunk.js","sourcesContent":["export const nodeItemType = 'node';\nexport const itemHeight = 40;\nexport const nestingPad = 40;\n","import React, { useCallback, useEffect, useMemo } from 'react';\nimport { inject, observer } from 'mobx-react';\nimport { useDrag } from 'react-dnd';\nimport classnames from 'classnames';\n\nimport { itemHeight, nestingPad, nodeItemType } from '../definitions';\n\nimport { EntityLabelStore } from '../../../mobx/EntityLabelStore';\nimport { DragAndDropStore } from '../../../mobx/DragAndDropStore';\n\nimport './index.css';\n\nconst defaultStyle = {\n  height: itemHeight,\n};\n\ntype ItemProps = {\n  id: number;\n  index: number;\n  entityLabelStore: EntityLabelStore;\n  dragAndDropStore: DragAndDropStore;\n};\n\nconst Item = inject(\n  'entityLabelStore',\n  'dragAndDropStore'\n)(\n  observer((props: ItemProps) => {\n    const node = props.entityLabelStore.map.get(props.id);\n    const [{ isDragging }, drag] = useDrag<{ id: number }, { name: string }, { isDragging: boolean }>(() => ({\n      type: nodeItemType,\n      item: { id: props.id },\n      end: () => {\n        props.dragAndDropStore.endDragging();\n      },\n      collect: (monitor) => ({\n        isDragging: monitor.isDragging(),\n      }),\n    }));\n\n    useEffect(() => {\n      if (isDragging) {\n        props.dragAndDropStore.startDragging(props.index);\n      }\n    }, [isDragging, props.index]);\n\n    const style = useMemo(() => {\n      return {\n        ...defaultStyle,\n        marginLeft: nestingPad * node.level,\n      };\n    }, [node.level]);\n\n    const handleClick = useCallback(() => {\n      props.entityLabelStore.setSelected(props.id);\n    }, [props.id]);\n\n    return (\n      <div className=\"NodeBox\" style={style} key={props.id}>\n        <button\n          type=\"button\"\n          onClick={handleClick}\n          ref={drag}\n          className={classnames({\n            Node: true,\n            Node_selected: props.entityLabelStore.selected.id === props.id,\n          })}\n        >\n          {node.label}\n        </button>\n      </div>\n    );\n  })\n);\n\ntype ExternalItemProps = {\n  id: number;\n  index: number;\n  entityLabelStore?: EntityLabelStore;\n  dragAndDropStore?: DragAndDropStore;\n};\n\nconst ExternalItem = Item as React.FC<ExternalItemProps>;\n\nexport { ExternalItem as Item };\n","import React, { DragEventHandler, useMemo, useRef, useState } from 'react';\nimport classnames from 'classnames';\n\nimport { nestingPad } from '../../definitions';\n\ntype Props = {\n  id: number;\n  nestingLevel: number;\n  base: boolean;\n  onDragOver: (pathId: number) => void;\n};\n\nexport const DropAcceptorSlot = ({ nestingLevel, onDragOver, id, base }: Props) => {\n  const [active, setActive] = useState(false);\n  const ref = useRef(null);\n  const style = useMemo(() => {\n    return {\n      marginLeft: nestingLevel * nestingPad,\n    };\n  }, [nestingLevel]);\n\n  const handleDragOver: DragEventHandler<HTMLDivElement> = () => {\n    onDragOver(id);\n    setActive(true);\n  };\n\n  const handleDragLeave: DragEventHandler<HTMLDivElement> = () => {\n    setActive(false);\n  };\n\n  const renderContent = () => {\n    return (\n      //\n      <div\n        ref={!base ? ref : undefined}\n        style={style}\n        className={classnames({\n          DropAcceptor__slot: true,\n          DropAcceptor__slot_active: active,\n        })}\n        onDragOver={!base ? handleDragOver : undefined}\n        onDragLeave={!base ? handleDragLeave : undefined}\n      />\n    );\n  };\n\n  if (base) {\n    return (\n      <div ref={ref} onDragOver={handleDragOver} onDragLeave={handleDragLeave}>\n        {renderContent()}\n      </div>\n    );\n  }\n\n  return renderContent();\n};\n","export const ROOT_ID = -1;\n","import React from 'react';\nimport { inject, observer } from 'mobx-react';\nimport classnames from 'classnames';\n\nimport { EntityLabelStore } from '../../../../mobx/EntityLabelStore';\nimport { DragAndDropStore } from '../../../../mobx/DragAndDropStore';\n\nimport './index.css';\nimport { DropAcceptorSlot } from './DropAcceptorSlot';\nimport { ROOT_ID } from '../../../../mobx/EntityLabelStore/definitions';\n\ntype Props = {\n  entityLabelStore: EntityLabelStore;\n  dragAndDropStore: DragAndDropStore;\n};\n\nconst renderSlots = (pathIds: number[], availableDropItemIndex: number, onDragOver: (pathId: number) => void) => {\n  const childAndSiblingIds = pathIds.slice(availableDropItemIndex);\n  const nestingStartLevel = Math.max(pathIds.length + availableDropItemIndex, 0);\n\n  return childAndSiblingIds.map((id, index) => {\n    return (\n      <DropAcceptorSlot //\n        key={id}\n        id={id}\n        base={index === 0}\n        nestingLevel={nestingStartLevel + index}\n        onDragOver={onDragOver}\n      />\n    );\n  });\n};\n\nconst DropAcceptor = inject(\n  'entityLabelStore',\n  'dragAndDropStore'\n)(\n  observer(({ entityLabelStore, dragAndDropStore }: Props) => {\n    const { dropAccessorIndex, isAbleDrop } = dragAndDropStore;\n    const handleDragOver = (pathId: number) => {\n      dragAndDropStore.setDropIntention({\n        parentId: pathId,\n        index: dropAccessorIndex,\n      });\n    };\n\n    const id = entityLabelStore._sequence[dropAccessorIndex - 1];\n    const node = entityLabelStore.map.get(id) ?? entityLabelStore.map.get(ROOT_ID);\n\n    const renderSlotsIfAble = () => {\n      if (!isAbleDrop) {\n        return null;\n      }\n\n      return renderSlots(node.path, dragAndDropStore.availableDropItemIndex, handleDragOver);\n    };\n\n    return (\n      <div>\n        <div\n          className={classnames({\n            DropAcceptor: true,\n            DropAcceptor_invalid: !isAbleDrop,\n          })}\n        />\n        {renderSlotsIfAble()}\n      </div>\n    );\n  })\n);\n\ntype ExternalProps = {\n  entityLabelStore?: EntityLabelStore;\n  dragAndDropStore?: DragAndDropStore;\n};\n\nconst DropAcceptorExternal = DropAcceptor as React.FC<ExternalProps>;\n\nexport { DropAcceptorExternal as DropAcceptor };\n","import React from 'react';\n\nimport './index.css';\n\nexport const StartDrag = () => {\n  return <div className=\"DragStart\" />;\n};\n","import React from 'react';\nimport { ObservableMap } from 'mobx';\n\nimport { Item } from './Item';\nimport { EntityLabelNode } from '../../../mobx/EntityLabel/EntityLabelNode';\nimport { VirtualScrollRange } from '../../../../../lib/VirtualScroll/types';\nimport { inject, observer } from 'mobx-react';\nimport { DragAndDropStore } from '../../../mobx/DragAndDropStore';\nimport { DropAcceptor } from './DropAcceptor';\n\nimport './index.css';\nimport { exhaustivenessCheck } from '../../../../../utils';\nimport { StartDrag } from './DragStart';\n\ntype Props = {\n  sequence: number[];\n  map: ObservableMap<number, EntityLabelNode>;\n  range: VirtualScrollRange;\n  dragAndDropStore: DragAndDropStore;\n};\n\ntype DraggingOptions = {\n  startDraggingIndex: number;\n  dropAccessorIndex: number;\n};\n\ntype DropAccessorSign = 'DROP_ACCESSOR_SIGN';\ntype StartDraggingSign = 'START_DRAGGING_SIGN';\nconst DROP_ACCESSOR_SIGN: DropAccessorSign = 'DROP_ACCESSOR_SIGN';\nconst START_DRAGGING_SIGN: StartDraggingSign = 'START_DRAGGING_SIGN';\ntype SequenceItem = DropAccessorSign | StartDraggingSign | number;\n\nconst mixinItemToSequence = (sequence: SequenceItem[], index: number, item: SequenceItem) => {\n  if (index === -1) {\n    return sequence;\n  }\n\n  const resultSequence: SequenceItem[] = [...sequence];\n  resultSequence.splice(index, 0, item);\n\n  return resultSequence;\n};\n\nconst getInsertionIndex = (index: number, range: VirtualScrollRange) => {\n  const outOfRange = index < range.from || index > range.to;\n\n  if (index === -1 || outOfRange) {\n    return -1;\n  }\n\n  return index - range.from;\n};\n\nconst mixinSpecialItems = (sequence: number[], range: VirtualScrollRange, { dropAccessorIndex, startDraggingIndex }: DraggingOptions) => {\n  const dropAccessorInsertionIndex = getInsertionIndex(dropAccessorIndex, range);\n  const startDraggingInsertionIndex = getInsertionIndex(startDraggingIndex, range);\n\n  let newSequence: SequenceItem[] = sequence;\n\n  newSequence = mixinItemToSequence(newSequence, dropAccessorInsertionIndex, DROP_ACCESSOR_SIGN);\n  newSequence = mixinItemToSequence(newSequence, startDraggingInsertionIndex, START_DRAGGING_SIGN);\n\n  return newSequence;\n};\n\nconst renderList = (props: Props, options: DraggingOptions) => {\n  const virtualSequence = props.sequence.slice(props.range.from, props.range.to);\n  const sequence = mixinSpecialItems(virtualSequence, props.range, options);\n\n  return sequence.map((id: SequenceItem, index) => {\n    if (id === DROP_ACCESSOR_SIGN) {\n      return <DropAcceptor key={DROP_ACCESSOR_SIGN} />;\n    }\n\n    if (id === START_DRAGGING_SIGN) {\n      return <StartDrag key={START_DRAGGING_SIGN} />;\n    }\n\n    if (typeof id === 'number') {\n      return <Item key={id} id={id} index={props.range.from + index} />;\n    }\n\n    exhaustivenessCheck(id);\n\n    return null;\n  });\n};\n\nconst TreeList = inject('dragAndDropStore')(\n  observer((props: Props) => {\n    const options: DraggingOptions = {\n      startDraggingIndex: props.dragAndDropStore.startDraggingIndex,\n      dropAccessorIndex: props.dragAndDropStore.dropAccessorIndex,\n    };\n\n    return <>{renderList(props, options)}</>;\n  })\n);\n\ntype ExternalProps = {\n  sequence: number[];\n  map: ObservableMap<number, EntityLabelNode>;\n  range: VirtualScrollRange;\n  dragAndDropStore?: DragAndDropStore;\n};\n\nconst TreeListExternal = TreeList as React.FC<ExternalProps>;\n\nexport { TreeListExternal as TreeList };\n","import React from 'react';\nimport { inject, observer } from 'mobx-react';\n\nimport { EntityLabelStore } from '../../mobx/EntityLabelStore';\n\nimport { TreeList } from './TreeList';\nimport { VirtualScrollStore } from '../../../../lib/VirtualScroll/mobx/VirtualScrollStore';\n\ntype Props = {\n  entityLabelStore: EntityLabelStore;\n  virtualScrollStore: VirtualScrollStore;\n};\n\nconst Tree = inject(\n  'entityLabelStore',\n  'virtualScrollStore'\n)(\n  observer(({ entityLabelStore, virtualScrollStore }: Props) => {\n    return (\n      <TreeList //\n        sequence={entityLabelStore._sequence}\n        map={entityLabelStore._map}\n        range={virtualScrollStore.range}\n      />\n    );\n  })\n);\n\ntype ExternalProps = {\n  entityLabelStore?: EntityLabelStore;\n  virtualScrollStore?: VirtualScrollStore;\n};\n\nconst ExternalTree = Tree as React.FC<ExternalProps>;\n\nexport { ExternalTree as Tree };\n","import { action, computed, observable } from 'mobx';\n\nimport { VirtualScrollStoreOptions } from './types';\n\nexport class VirtualScrollStore {\n  @observable\n  scrollAreaHeight: number;\n\n  @observable\n  scrollPosition: number;\n\n  @observable\n  itemHeight: number;\n\n  @observable\n  itemsTotal: number;\n\n  constructor(options: VirtualScrollStoreOptions) {\n    this.scrollAreaHeight = 0;\n    this.itemHeight = options.itemHeight ?? 0;\n    this.scrollPosition = 0;\n    this.itemsTotal = options.itemsTotal;\n  }\n\n  @action\n  setScrollAreaHeight(height: number) {\n    this.scrollAreaHeight = height;\n  }\n\n  @action\n  setScrollPosition(scrollPosition: number) {\n    this.scrollPosition = scrollPosition;\n  }\n\n  @action\n  setItemHeight(itemHeight: number) {\n    this.itemHeight = itemHeight;\n  }\n\n  @action\n  setItemsTotal(itemsTotal: number) {\n    this.itemsTotal = itemsTotal;\n  }\n\n  @computed\n  get from() {\n    return Math.floor(this.scrollPosition / this.itemHeight);\n  }\n\n  @computed\n  get to() {\n    const to = this.from + Math.ceil(this.scrollAreaHeight / this.itemHeight) + 1;\n\n    return Math.min(to, this.itemsTotal);\n  }\n\n  @computed\n  get range() {\n    return {\n      from: this.from,\n      to: this.to,\n    };\n  }\n\n  @computed\n  get contentHeight() {\n    return this.itemsTotal * this.itemHeight;\n  }\n\n  @computed\n  get pads() {\n    const paddingBottom = this.contentHeight - (this.range.to + 1) * this.itemHeight;\n    return {\n      paddingTop: this.range.from * this.itemHeight,\n      paddingBottom: Math.max(0, paddingBottom),\n    };\n  }\n}\n","import React, { useEffect, useMemo, useRef } from 'react';\nimport { inject, observer } from 'mobx-react';\n\nimport { VirtualScrollStore } from './mobx/VirtualScrollStore';\nimport { ScrollAreaContainer } from './types';\n\ntype Props = {\n  children: (range: { from: number; to: number }) => JSX.Element;\n  virtualScrollStore: VirtualScrollStore;\n  Container: ScrollAreaContainer;\n};\n\nconst VisualScrollArea = inject('virtualScrollStore')(\n  observer((props: Props) => {\n    const scrollStore = props.virtualScrollStore;\n    const scrollAreaRef = useRef(null);\n\n    useEffect(() => {\n      const handleScroll = (event) => {\n        const scrollTop = event.target.scrollTop;\n\n        scrollStore.setScrollPosition(scrollTop);\n      };\n\n      if (scrollAreaRef.current) {\n        scrollAreaRef.current.addEventListener('scroll', handleScroll);\n        scrollStore.setScrollAreaHeight(scrollAreaRef.current.offsetHeight);\n      }\n\n      return () => {\n        if (scrollAreaRef.current) {\n          scrollAreaRef.current.removeEventListener('scroll', handleScroll);\n        }\n      };\n    }, []);\n\n    const ScrollArea = props.Container;\n\n    const pads = scrollStore.pads;\n    const style = useMemo(() => {\n      return pads;\n    }, [pads.paddingTop, pads.paddingBottom]);\n\n    return (\n      <ScrollArea style={style} ref={scrollAreaRef}>\n        {props.children({\n          from: scrollStore.from,\n          to: scrollStore.to,\n        })}\n      </ScrollArea>\n    );\n  })\n);\n\ntype ExternalProps = {\n  children: (range: { from: number; to: number }) => JSX.Element;\n  virtualScrollStore?: VirtualScrollStore;\n  Container: ScrollAreaContainer;\n};\n\nconst VisualScrollAreaExternal = VisualScrollArea as React.FC<ExternalProps>;\n\nexport { VisualScrollAreaExternal as VisualScrollArea };\n","import React, { useEffect, useState } from 'react';\nimport { Provider } from 'mobx-react';\n\nimport { VirtualScrollStore } from './mobx/VirtualScrollStore';\nimport { VirtualScrollStoreOptions } from './mobx/types';\nimport { VisualScrollArea } from './VirtualScrollArea';\n\nimport { ScrollAreaContainer } from './types';\n\ntype Props = {\n  children: (range: { from: number; to: number }) => React.ReactElement;\n  options: VirtualScrollStoreOptions;\n  Container: ScrollAreaContainer;\n};\n\nconst createStores = (options) => {\n  return {\n    virtualScrollStore: new VirtualScrollStore(options),\n  };\n};\n\nexport const VirtualScroll = ({ children, options, Container }: Props) => {\n  const [stores] = useState(() => createStores(options));\n\n  useEffect(() => {\n    stores.virtualScrollStore.setItemsTotal(options.itemsTotal);\n  }, [options.itemsTotal]);\n\n  return (\n    <Provider {...stores}>\n      <VisualScrollArea Container={Container}>{children}</VisualScrollArea>\n    </Provider>\n  );\n};\n","import React, { DragEventHandler, useRef } from 'react';\nimport { inject } from 'mobx-react';\nimport { useDrop } from 'react-dnd';\n\nimport { VirtualScrollContainerStyle } from '../../../lib/VirtualScroll/types';\nimport { itemHeight, nodeItemType } from './Tree/definitions';\nimport { DragAndDropStore } from '../mobx/DragAndDropStore';\n\ntype Props = {\n  style: VirtualScrollContainerStyle;\n  children: React.ReactNode;\n  dragAndDropStore: DragAndDropStore;\n};\n\ntype DropItem = {\n  id: number;\n};\n\nconst DropContainer = inject('dragAndDropStore')(({ style, children, dragAndDropStore }: Props) => {\n  useRef(null);\n  const [_, drop] = useDrop(() => ({\n    accept: nodeItemType,\n    drop: (item: DropItem) => {\n      dragAndDropStore.drop(item.id);\n    },\n  }));\n\n  const handleDragOver: DragEventHandler<HTMLDivElement> = (event) => {\n    if (event.currentTarget) {\n      const dropAreaRect = event.currentTarget.getBoundingClientRect();\n      const mouseY = event.clientY - dropAreaRect.top;\n      const mouseIndex = Math.floor(mouseY / itemHeight);\n\n      dragAndDropStore.setMouseIndex(mouseIndex);\n    }\n  };\n\n  return (\n    //\n    <div ref={drop} onDragOver={handleDragOver} style={style}>\n      {children}\n    </div>\n  );\n});\n\ntype PropsExternal = {\n  style: VirtualScrollContainerStyle;\n  children: React.ReactNode;\n  dragAndDropStore?: DragAndDropStore;\n};\n\nconst DropContainerExternal = DropContainer as React.FC<PropsExternal>;\n\nexport { DropContainerExternal as DropContainer };\n","import React, { LegacyRef } from 'react';\n\nimport { VirtualScrollContainerStyle } from '../../../lib/VirtualScroll/types';\nimport { DropContainer } from './DropContainer';\n\ntype Props = {\n  children: React.ReactElement | (() => JSX.Element);\n  forwardRef: LegacyRef<HTMLDivElement>;\n  style: VirtualScrollContainerStyle;\n};\n\nconst ScrollContainer = ({ children, forwardRef, style }: Props) => {\n  return (\n    <div className=\"VirtualScrollTree\" ref={forwardRef}>\n      <DropContainer style={style}>{children}</DropContainer>\n    </div>\n  );\n};\n\ntype BoxProps = {\n  children: React.ReactElement | (() => JSX.Element);\n  style: VirtualScrollContainerStyle;\n};\n\nconst ScrollContainerBox = React.forwardRef((props: BoxProps, ref) => {\n  return <ScrollContainer {...props} forwardRef={ref as LegacyRef<HTMLDivElement>} />;\n});\n\nexport { ScrollContainerBox as ScrollContainer };\n","import React, { useMemo } from 'react';\nimport { inject, observer } from 'mobx-react';\n\nimport { Tree } from './Tree';\nimport { VirtualScroll } from '../../../lib/VirtualScroll';\nimport { ScrollContainer } from './ScrollContainer';\nimport { itemHeight } from './Tree/definitions';\n\nimport './index.css';\nimport { EntityLabelStore } from '../mobx/EntityLabelStore';\n\nconst renderList = () => {\n  return <Tree />;\n};\n\nconst defaultScrollOptions = {\n  itemHeight,\n};\n\ntype Props = {\n  entityLabelStore: EntityLabelStore;\n};\n\nconst VirtualScrollTree = inject('entityLabelStore')(\n  observer((props: Props) => {\n    const itemsTotal = props.entityLabelStore._sequence.length;\n    const scrollOptions = useMemo(() => {\n      return {\n        ...defaultScrollOptions,\n        itemsTotal,\n      };\n    }, [itemsTotal]);\n\n    return (\n      <VirtualScroll Container={ScrollContainer} options={scrollOptions}>\n        {renderList}\n      </VirtualScroll>\n    );\n  })\n);\n\ntype ExternalProps = {\n  entityLabelStore?: EntityLabelStore;\n};\n\nconst VirtualScrollTreeExternal = VirtualScrollTree as React.FC<ExternalProps>;\n\nexport { VirtualScrollTreeExternal as VirtualScrollTree };\n","import React from 'react';\nimport { inject, observer } from 'mobx-react';\n\nimport { ROOT_ID } from '../mobx/EntityLabelStore/definitions';\nimport { EntityLabelStore } from '../mobx/EntityLabelStore';\n\nimport './index.css';\n\ntype Props = {\n  entityLabelStore: EntityLabelStore;\n};\n\nconst SelectedInfo = inject('entityLabelStore')(\n  observer(({ entityLabelStore }: Props) => {\n    const { selected } = entityLabelStore;\n\n    if (selected.id === ROOT_ID) {\n      return null;\n    }\n\n    return (\n      <>\n        <div>\n          <strong>id:</strong> {selected.id}\n        </div>\n        <div>\n          <strong>label:</strong> {selected.label}\n        </div>\n        <div>\n          <strong>parentId:</strong> {selected.parent.id}\n        </div>\n      </>\n    );\n  })\n);\n\ntype ExternalProps = {\n  entityLabelStore?: EntityLabelStore;\n};\n\nconst ExternalSelectedInfo = SelectedInfo as React.FC<ExternalProps>;\n\nexport { ExternalSelectedInfo as SelectedInfo };\n","import React from 'react';\n\nimport './index.css';\nimport { SelectedInfo } from './SelectedInfo';\n\nexport const Info = () => {\n  return (\n    <div className=\"Info\">\n      <SelectedInfo />\n    </div>\n  );\n};\n","import React, { useCallback } from 'react';\nimport { inject, observer } from 'mobx-react';\n\nimport { EntityLabelStore } from '../mobx/EntityLabelStore';\nimport { ROOT_ID } from '../mobx/EntityLabelStore/definitions';\n\nimport './index.css';\n\ntype Props = {\n  entityLabelStore: EntityLabelStore;\n};\n\nconst Controls = inject('entityLabelStore')(\n  observer((props: Props) => {\n    const handleRefresh = useCallback(() => {\n      props.entityLabelStore.fetch();\n    }, [props.entityLabelStore]);\n\n    const handleRemove = useCallback(() => {\n      props.entityLabelStore.removeSelected();\n    }, [props.entityLabelStore]);\n\n    const handleApply = useCallback(() => {\n      props.entityLabelStore.apply();\n    }, [props.entityLabelStore]);\n\n    return (\n      <div className=\"Controls\">\n        <button className=\"Controls__button\" type=\"button\" onClick={handleApply}>\n          Apply\n        </button>\n        <button className=\"Controls__button\" type=\"button\" disabled={props.entityLabelStore.pending} onClick={handleRefresh}>\n          Refresh\n        </button>\n        <button className=\"Controls__button\" type=\"button\" disabled={props.entityLabelStore.selected.id === ROOT_ID} onClick={handleRemove}>\n          Remove\n        </button>\n      </div>\n    );\n  })\n);\n\ntype ExternalProps = {\n  entityLabelStore?: EntityLabelStore;\n};\n\nconst ControlsExternal = Controls as React.FC<ExternalProps>;\n\nexport { ControlsExternal as Controls };\n","import React from 'react';\n\nimport { VirtualScrollTree } from './VirtualScrollTree';\nimport { Info } from './Info';\nimport { Controls } from './Controls';\n\nimport './index.css';\n\nexport const TreeEditor = () => {\n  return (\n    <div className=\"TreeEditor\">\n      <div className=\"TreeEditor__viewport\">\n        <VirtualScrollTree />\n        <Info />\n      </div>\n      <Controls />\n    </div>\n  );\n};\n","import React from 'react';\n\nimport { TreeEditor } from './TreeEditor';\nimport './index.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <TreeEditor />\n    </div>\n  );\n}\n\nexport default App;\n","import { EntityLabelNode } from './EntityLabelNode';\n\nexport const emptyEntityLabelNode: EntityLabelNode = {\n  get id() {\n    return -1;\n  },\n  get label() {\n    return '';\n  },\n  get parent() {\n    return emptyEntityLabelNode;\n  },\n  children: [],\n  setParent() {},\n  addChild() {},\n  getBranchMembers() {\n    return [];\n  },\n  removeChild(node: EntityLabelNode) {},\n  get level() {\n    return 0;\n  },\n  getData() {\n    return {\n      id: this.id,\n      label: this.label,\n      parentId: this.parent.id,\n    };\n  },\n  get path() {\n    return [];\n  },\n  get isLastChild() {\n    return false;\n  },\n};\n","import { observable } from 'mobx';\n\nimport { EntityLabelNode } from './EntityLabelNode';\nimport { ROOT_ID } from '../EntityLabelStore/definitions';\n\nexport type EntryLabelOptions = {\n  id: number;\n\n  label: string;\n\n  parent: EntityLabelNode;\n\n  children: EntityLabelNode[];\n};\n\nexport class EntityLabel implements EntityLabelNode {\n  _id: number;\n\n  _label: string;\n\n  @observable _parent: EntityLabelNode;\n\n  /**\n   * keep actual children order\n   */\n  @observable _children: EntityLabelNode[];\n\n  constructor(options: EntryLabelOptions) {\n    this._id = options.id;\n    this._label = options.label;\n    this._parent = options.parent;\n    this._children = options.children;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get label() {\n    return this._label;\n  }\n\n  get parent() {\n    return this._parent;\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  get level() {\n    if (this.parent.id === ROOT_ID) {\n      return 0;\n    }\n\n    return this.parent.level + 1;\n  }\n\n  get path() {\n    const parentPath = this.parent.path;\n\n    return [...parentPath, this.id];\n  }\n\n  removeChild(child: EntityLabelNode) {\n    const index = this._children.indexOf(child);\n\n    if (index !== -1) {\n      this._children.splice(index, 1);\n    }\n  }\n\n  getBranchMembers() {\n    const allSubBranchMembers = this.children.reduce((result, child) => {\n      result.push(...child.getBranchMembers());\n\n      return result;\n    }, []);\n\n    const result = [this, ...allSubBranchMembers];\n\n    return result;\n  }\n\n  setParent(parent: EntityLabelNode) {\n    this._parent = parent;\n  }\n\n  addChild(child: EntityLabelNode, index = -1) {\n    if (index !== -1) {\n      this._children.splice(index, 0, child);\n\n      return;\n    }\n\n    this._children.push(child);\n  }\n\n  getData() {\n    return {\n      id: this.id,\n      label: this.label,\n      parentId: this.parent.id,\n    };\n  }\n\n  get isLastChild() {\n    const length = this.parent.children.length;\n    const last = this.parent.children[length - 1];\n\n    return length > 0 ? last.id === this.id : false;\n  }\n}\n","import { observable, action, ObservableMap, computed } from 'mobx';\nimport invariant from 'invariant';\n\nimport { EntityLabelNode } from '../EntityLabel/EntityLabelNode';\nimport { emptyEntityLabelNode } from '../EntityLabel/emptyEntityLabelNode';\nimport { EntityLabel } from '../EntityLabel';\n\nimport type { EntityLabelPage, EntityLabelResponse } from './types';\nimport { ROOT_ID } from './definitions';\nimport { NodeLocation } from '../DragAndDropStore/types';\n\nconst RESOURCE = 'https://gist.githubusercontent.com/avydashenko/e1702c1ef26cddd006da989aa47d4f62/raw/067f7b75946baf7faf5b8afcd04c66ecf0b47486/view.json';\n\nexport class EntityLabelStore {\n  sequenceStash: number[];\n\n  @observable\n  _selected: EntityLabelNode;\n\n  @observable\n  _sequence: number[];\n\n  @observable\n  _map: ObservableMap<number, EntityLabelNode>;\n\n  _rootNode: EntityLabelNode;\n\n  @observable\n  _pending: boolean;\n\n  constructor() {\n    this._sequence = [];\n    this._rootNode = new EntityLabel({\n      id: ROOT_ID,\n      label: '',\n      parent: emptyEntityLabelNode,\n      children: [],\n    });\n    this._map = this.createMap();\n    this._selected = emptyEntityLabelNode;\n    this._pending = false;\n    this.sequenceStash = [];\n\n    this.fetch();\n  }\n\n  createMap() {\n    const map = new Map([[this._rootNode.id, this._rootNode]]);\n\n    return observable.map<number, EntityLabelNode>(map);\n  }\n\n  moveSequence(sourceIndex: number, childrenEndIndex: number, targetPosition: NodeLocation) {\n    const sequence = this._sequence;\n    const removementLength = childrenEndIndex - sourceIndex;\n    const branch = sequence.splice(sourceIndex, removementLength);\n\n    let targetIndex = targetPosition.index;\n\n    if (sourceIndex < targetPosition.index) {\n      targetIndex = targetPosition.index - removementLength;\n    }\n\n    sequence.splice(targetIndex, 0, ...branch);\n  }\n\n  updateNestingPointers(sourceIndex: number, targetPosition: NodeLocation) {\n    const sequence = this._sequence;\n    const sourceId = sequence[sourceIndex];\n    const sourceNode = this._map.get(sourceId);\n\n    const targetParent = this._map.get(targetPosition.parentId);\n\n    let childItem = null;\n    let currentItem = null;\n    for (let i = targetPosition.index - 1; targetParent !== currentItem && i >= 0; i--) {\n      currentItem = this._map.get(sequence[i]);\n\n      if (targetParent === currentItem) {\n        break;\n      }\n\n      if (currentItem.parent === targetParent) {\n        childItem = currentItem;\n        break;\n      }\n    }\n\n    let insertIndex: number;\n    if (childItem) {\n      const closestUpperSiblingIndex = targetParent.children.indexOf(childItem);\n      insertIndex = closestUpperSiblingIndex + 1;\n    } else {\n      insertIndex = 0;\n    }\n\n    sourceNode.parent.removeChild(sourceNode);\n\n    sourceNode.setParent(targetParent);\n\n    targetParent.addChild(sourceNode, insertIndex);\n  }\n\n  moveNode(sourceIndex: number, targetPosition: NodeLocation) {\n    const sequence = this._sequence;\n    const sourceId = sequence[sourceIndex];\n    const sourceNode = this._map.get(sourceId);\n    const sourceParentPath = sourceNode.parent.path;\n    const sourceParentPathSet = new Set(sourceParentPath);\n\n    const length = sequence.length;\n    let childrenEndIndex = sourceIndex + 1;\n    for (let i = childrenEndIndex; i < length; i++) {\n      const currentItem = this._map.get(sequence[i]);\n      if (sourceParentPathSet.has(currentItem.parent.id) || i === length - 1) {\n        childrenEndIndex = i;\n\n        break;\n      }\n    }\n\n    this.updateNestingPointers(sourceIndex, targetPosition);\n    this.moveSequence(sourceIndex, childrenEndIndex, targetPosition);\n  }\n\n  @action\n  initMap(entityLabelPage: EntityLabelPage) {\n    this._map = this.createMap();\n\n    entityLabelPage.entityLongIds.forEach((id: number, index: number) => {\n      const label = entityLabelPage.labels[index];\n\n      const entryLabel = new EntityLabel({\n        id,\n        label,\n        parent: emptyEntityLabelNode,\n        children: [],\n      });\n\n      this._map.set(id, entryLabel);\n    }, {} as { [key: number]: EntityLabelNode });\n\n    entityLabelPage.entityLongIds.forEach((id: number, index: number) => {\n      const parentId = entityLabelPage.parentEntityLongIds[index];\n      const parent = this._map.get(parentId) as EntityLabelNode;\n      const child = this._map.get(id) as EntityLabelNode;\n\n      child.setParent(parent);\n      parent.addChild(child);\n    });\n  }\n\n  @action('set data')\n  setData(entityLabelPage: EntityLabelPage) {\n    this._selected = emptyEntityLabelNode;\n    this._sequence = entityLabelPage.entityLongIds;\n    this.initMap(entityLabelPage);\n  }\n\n  @action\n  setPending(pending: boolean) {\n    this._pending = pending;\n  }\n\n  @action('load entity labels')\n  async fetch() {\n    this.setPending(true);\n\n    try {\n      const response = await fetch(RESOURCE, { method: 'GET' });\n\n      invariant(response.ok, 'EntityLabel http request failed');\n\n      const data = await (response.json() as Promise<EntityLabelResponse>);\n\n      // Trust server to return us valid data.\n      this.setData(data.entityLabelPages[0]);\n    } catch (error) {\n      console.log(error);\n    }\n\n    this.setPending(false);\n  }\n\n  @action('entity label remove selected')\n  removeSelected() {\n    if (this._selected === emptyEntityLabelNode) {\n      return;\n    }\n\n    this._selected.parent.removeChild(this._selected);\n\n    const branchMemberIds = this._selected.getBranchMembers().map((item) => {\n      return item.id;\n    });\n\n    const removeIds = new Set(branchMemberIds);\n    this._sequence = this._sequence.filter((id) => {\n      return !removeIds.has(id);\n    });\n\n    branchMemberIds.forEach((id: number) => {\n      this._map.delete(id);\n    });\n\n    this._selected = emptyEntityLabelNode;\n  }\n\n  @action('entity label apply')\n  apply() {\n    const result = {};\n\n    let path = [this._map.get(-1)];\n    const updatePath = (item: EntityLabelNode) => {\n      const parentIndex = path.indexOf(item.parent);\n      if (parentIndex !== -1) {\n        path = path.slice(0, parentIndex + 1);\n      } else {\n        path.push(item.parent);\n      }\n    };\n\n    const applyNode = (node: EntityLabelNode) => {\n      const data = node.getData();\n      const branch = path.reduce((branch, pathItem) => {\n        if (pathItem.id === ROOT_ID) {\n          return branch;\n        }\n\n        invariant(branch[pathItem.id], 'Invalid tree structure');\n\n        if (!branch[pathItem.id].children) {\n          branch[pathItem.id].children = {};\n        }\n\n        const nextBranch = branch[pathItem.id].children;\n\n        return nextBranch;\n      }, result);\n\n      branch[data.id] = data;\n    };\n\n    this._sequence.forEach((id, index) => {\n      const item = this._map.get(id);\n\n      updatePath(item);\n      applyNode(item);\n    });\n\n    console.log(result);\n  }\n\n  @action\n  setSelected(id: number) {\n    const selected = this._map.get(id);\n\n    this._selected = selected;\n  }\n\n  @computed\n  get sequence() {\n    return this._sequence;\n  }\n\n  @computed\n  get map() {\n    return this._map;\n  }\n\n  @computed\n  get selected() {\n    return this._selected;\n  }\n\n  @computed\n  get pending() {\n    return this._pending;\n  }\n\n  @action\n  removeSequenceItemAndStash(index) {\n    this.sequenceStash = [...this._sequence];\n    this._sequence.splice(index, 1);\n  }\n\n  @action\n  unstash() {\n    this._sequence = this.sequenceStash;\n  }\n}\n","import { action, computed, observable } from 'mobx';\n\nimport { EntityLabelStore } from '../EntityLabelStore';\nimport { NodeLocation } from './types';\nimport { ROOT_ID } from '../EntityLabelStore/definitions';\nimport { emptyEntityLabelNode } from '../EntityLabel/emptyEntityLabelNode';\n\nconst emptyDropIntention: NodeLocation = {\n  index: -1,\n  parentId: -1,\n};\n\nconst DEFAULT_AVAILABLE_DROP_INDEX = -2;\n\nexport class DragAndDropStore {\n  @observable\n  entityLabelStore: EntityLabelStore;\n\n  @observable\n  _mouseIndex: number;\n\n  @observable\n  dragging: boolean;\n\n  @observable\n  dropIntention: NodeLocation;\n\n  @observable\n  _startDraggingIndex: number;\n\n  constructor(entityLabelStore: EntityLabelStore) {\n    this.entityLabelStore = entityLabelStore;\n    this.dropIntention = emptyDropIntention;\n    this._startDraggingIndex = -1;\n  }\n\n  @computed\n  get dropAccessorIndex() {\n    return this.dragging ? this._mouseIndex : -1;\n  }\n\n  @computed\n  get startDraggingIndex() {\n    return this.dragging ? this._startDraggingIndex : -1;\n  }\n\n  @computed\n  get onlyChildDropAllowed() {\n    const draggingItemId = this.entityLabelStore.sequenceStash[this.dropAccessorIndex] ?? ROOT_ID;\n    const upperItemId = this.entityLabelStore.sequenceStash[this.dropAccessorIndex - 1] ?? ROOT_ID;\n    const upperItem = this.entityLabelStore.map.get(upperItemId);\n    const draggingItem = this.entityLabelStore.map.get(draggingItemId);\n    const onlyOneDraggingChild = draggingItem.parent.id === upperItem.id && upperItem.children.length === 1;\n\n    return !!upperItem.children.length && !onlyOneDraggingChild;\n  }\n\n  @computed\n  get dropIndexByUpperItemLastChild() {\n    const upperItemId = this.entityLabelStore._sequence[this.dropAccessorIndex - 1] ?? ROOT_ID;\n\n    if (upperItemId === ROOT_ID) {\n      return -1;\n    }\n\n    const currentId = this.entityLabelStore.sequenceStash[this.dropAccessorIndex] ?? ROOT_ID;\n    const currentItem = this.entityLabelStore.map.get(currentId) ?? emptyEntityLabelNode;\n\n    const upperItem = this.entityLabelStore.map.get(upperItemId) ?? emptyEntityLabelNode;\n    const path = upperItem.path.reverse();\n    let result = DEFAULT_AVAILABLE_DROP_INDEX;\n\n    for (let i = 0; i < path.length; i++) {\n      const item = this.entityLabelStore.map.get(path[i]);\n      const isLastItemCurrent = i === 0 && currentItem.isLastChild && item.parent.id === currentItem.parent.id;\n\n      if (item.isLastChild || isLastItemCurrent) {\n        result = result - 1;\n      } else {\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  @computed\n  get availableDropItemIndex() {\n    if (this.onlyChildDropAllowed) {\n      return -1;\n    }\n\n    return this.dropIndexByUpperItemLastChild;\n  }\n\n  @computed\n  get isAbleDrop() {\n    if (this.dropAccessorIndex !== -1 && this._startDraggingIndex !== -1) {\n      const startId = this.entityLabelStore.sequenceStash[this._startDraggingIndex];\n      const endId = this.entityLabelStore._sequence[this.dropAccessorIndex - 1] ?? ROOT_ID;\n      const endItem = this.entityLabelStore.map.get(endId);\n      const endItemParents = new Set(endItem.path);\n\n      return !endItemParents.has(startId);\n    }\n\n    return false;\n  }\n\n  @action\n  setDropIntention(dropIntention: NodeLocation) {\n    this.dropIntention = dropIntention;\n  }\n\n  @action\n  setMouseIndex(index: number) {\n    this._mouseIndex = index;\n  }\n\n  @action\n  startDragging(index: number) {\n    this._startDraggingIndex = index;\n    this.entityLabelStore.removeSequenceItemAndStash(index);\n\n    this.dragging = true;\n  }\n\n  @action\n  endDragging() {\n    if (this.dragging) {\n      this.entityLabelStore.unstash();\n      this.dragging = false;\n    }\n  }\n\n  @action\n  drop(id: number) {\n    const sourceIndex = this.entityLabelStore.sequenceStash.indexOf(id);\n    const isAbleDrop = this.isAbleDrop; // strictly before unstash and dragging cancel\n\n    this.dragging = false;\n    this.entityLabelStore.unstash();\n\n    if (this.dropIntention.index !== -1 && isAbleDrop && sourceIndex !== -1) {\n      const targetPosition = {\n        //\n        parentId: this.dropIntention.parentId,\n        index: this.dropIntention.index,\n      };\n\n      if (sourceIndex < targetPosition.index) {\n        const sourceItemNotDisplayedCorrection = 1;\n        targetPosition.index = targetPosition.index + sourceItemNotDisplayedCorrection;\n      }\n\n      this.entityLabelStore.moveNode(sourceIndex, targetPosition);\n    }\n  }\n\n  @computed\n  get mouseIndex() {\n    return this._mouseIndex;\n  }\n}\n","import { EntityLabelStore } from './App/TreeEditor/mobx/EntityLabelStore';\nimport { DragAndDropStore } from './App/TreeEditor/mobx/DragAndDropStore';\n\nconst entityLabelStore = new EntityLabelStore();\n\nexport const stores = {\n  entityLabelStore,\n  dragAndDropStore: new DragAndDropStore(entityLabelStore),\n};\n","import React from 'react';\nimport { Provider } from 'mobx-react';\nimport { DndProvider } from 'react-dnd';\nimport { HTML5Backend } from 'react-dnd-html5-backend';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { stores } from './stores';\n\nReactDOM.render(\n  <React.StrictMode>\n    <DndProvider backend={HTML5Backend}>\n      <Provider {...stores}>\n        <App />\n      </Provider>\n    </DndProvider>\n  </React.StrictMode>,\n  document.getElementById('root') as HTMLElement\n);\n\nconst f1 = async () => {\n  return Promise.resolve('f1');\n};\n\nconst f2 = async () => {\n  console.log('1');\n  queueMicrotask(() => {\n    console.log('queueMicrotask');\n  });\n  await f1();\n  console.log('2');\n  await f1();\n  console.log('3');\n};\n\nconst runTimeouts = () => {\n  for (let i = 0; i < 1000000; i++) {\n    setTimeout(() => {\n      console.log('timeout');\n    }, 0);\n  }\n};\n\nconst f3 = async () => {\n  console.log('f3!');\n  queueMicrotask(() => {\n    console.log('queueMicrotask f3!');\n  });\n  runTimeouts();\n  await f2();\n  console.log('f3! after');\n  queueMicrotask(() => {\n    console.log('queueMicrotask f3! after');\n  });\n};\n\nf3();\n"],"sourceRoot":""}